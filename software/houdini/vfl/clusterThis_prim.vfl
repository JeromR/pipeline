#include <math.h>

void testBound(string name)
{
    if (isbound(name))
	printf("%s is bound\n", name);
    else
	printf("%s is not bound\n", name);
}

cvex clusterThis_prim(
     vector P=0;
    export vector POut=0;
     vector N=0;
//    export vector NOut=0;
/*     vector v=0;
    export vector vOut=0;
     vector Cd=0;
    export vector CdOut=0;
     float Alpha=0;
    export float AlphaOut=0;
     float pscale=0;
    export float pscaleOut=0;*/
     int id=0;
     int inst_id=0;
     int mb_pass=0;
/*
   float f_offset=0.5;
   float f_amp=1.2;
   float f_wavelength=2.0;
   float f_dropoff=0;
   float f_high_bound=1.0;
   float f_low_bound=-1.0;
   vector  f_t  = 0;
   vector  f_r = 0;
   vector  f_s = 1;
   vector  f_p = 0;


    // Deform Space
    int     xOrd        = 0;
    int     rOrd        = 0;
*/

)
{
    printf("Running clusterThis_prim.vex\n");
  
    testBound("P");
    testBound("N");
    testBound("v");
    testBound("Cd");
    testBound("Alpha");
    testBound("pscale");
    testBound("id");
    testBound("inst_id");
    testBound("mb_pass");




   float f_offset=0.5;
   float f_amp=1.2;
   float f_wavelength=2.0;
   float f_dropoff=0;
   float f_high_bound=1.0;
   float f_low_bound=-1.0;
   vector  f_t  = 0;
   vector  f_r = 0;
   vector  f_s = 1;
   vector  f_p = 0;

    int     xOrd        = 0;
    int     rOrd        = 0;


//     printf("P: %g\tN: %g\tv: %g\tAlpha: %g\tpscale: %g\n", P, N, v, Alpha, pscale);
     
    matrix obj_origin = ident();
    matrix inv_obj_origin = ident();
    matrix dspace = ident();
    matrix inv_dspace = ident();

    obj_origin = maketransform(xOrd,rOrd,P,N,{1,1,1},{0,0,0});
//    world_origin = maketransform(xOrd,rOrd,w_t,w_r,w_s,w_p);
//    dspace = maketransform(xOrd,rOrd,f_t,f_r,f_s,f_p);
//    inv_dspace = invert(dspace);
    inv_obj_origin = invert(obj_origin);

//    vector worldP = ptransform(P, world_origin);
    vector deformP = ptransform(P, inv_obj_origin);

    float freq = (M_PI*2)/f_wavelength;
    float y = deformP.y;
//    printf("y1: %g\n", y);

    y = clamp(y,f_low_bound,f_high_bound);
//    printf("y2: %g\n", y);

    float bound =  (y>= 0.0) ? f_high_bound: f_low_bound;
    float falloff = abs(y)/abs(bound);

    if ( f_dropoff > 0.0 ) {
        falloff = 1 - falloff;
    }

    falloff = lerp(1,falloff,abs(f_dropoff));
    falloff *= f_amp;

//    printf("y3: %g\n", y);
//    printf("falloff: %g\n", falloff);

    // Calculate the displacement
    float f_displace_sine = sin((y*freq) + (f_offset*freq));
    f_displace_sine *= falloff;

//    printf("f_displace_sine: %g\n", f_displace_sine);

    // Move the point ... 
    deformP.x += f_displace_sine;



    // Reverse deform space
    deformP = ptransform(deformP, dspace);
    // Return to world space
    POut = ptransform(deformP, obj_origin);


//    POut = P;  
//    POut = {0,0,0};  
//    POut.y *= 1.05;    
//    vOut = v * 1.5;    

//    vOut = v * random(inst_id) * 3.0;
// 
//    if(mb_pass == 0) {
//       CdOut = {.5, 0.9, 0.7} * Cd;
// //      printf("CdOut: %g\n", CdOut);    
//       }
//    else {
//       CdOut = {1, 1, 0}  * Cd;
// //      printf("MB: CdOut: %g\n", CdOut);    
//       }
// 
//       CdOut = {1, .5, 0};
//     
//    AlphaOut = Alpha * 0.95;    

/*   pscaleOut = pscale * pow(random(inst_id), 3.33) * pow(random(inst_id), 2.37);
   pscaleOut *= 3.0;
   
   NOut = N * random(inst_id);*/
//   NOut = N * 1.0;
   
// printf("Cd: %g\tCdOut: %g\n", Cd, CdOut);    
// printf("mb_pass: %g\n", mb_pass);    
// printf("id: %g\n", id);    
// printf("inst_id: %g\n", inst_id);    
// printf("POut: %g\tNOut: %g\tAlphaOut: %g\tvOut: %g\tpscaleOut: %g\n", POut, NOut, AlphaOut, vOut, pscaleOut);


}
